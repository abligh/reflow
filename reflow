#!/usr/bin/perl

# reflow - reformat a mail message sensibly
#
# (c) 2012 Alex Bligh <alex@alex.org.uk>
#
#  Licensed under the Apache licence - see LICENSE for details

use strict;
use warnings;
use Getopt::Long;
use FindBin;

use constant
{
    wrap=>1,
    signature=>2,
    dontwrap=>3
};

my $option_width = 76;
my $option_stripsignature = 0;
my $option_quote = 0;
my $option_indent = 0;
my $option_maxquote = 10;
my $option_minwidth = 20;

my @unquotedlines;
my @rawlines;
my $quotes=0;
my $mode = wrap;
my $lastblank = 0;

sub Syntax
{
    print STDERR <<STOP;

Usage: $FindBin::Script [options] < INFILE > OUTFILE

Options:
  -w, --width N               Set width to N (default 76)
  -s, --strip-signature       Strip email signatures
  -q, --quote N               Increase quotation level by N, or
                              decrease quotation level by -N
  -i, --indent N              Increase indent level by 4N, or
                              decrease indent level by -4N
  -m, --max-quote N           Maximum quotation level of N
                              (default 10)
  -y, --min-width N           Minimum text width of N
                              (default 20)
  -h, --help                  Print this message

STOP
    return;
}

sub ParseOptions
{
    if (!GetOptions (
             "width|w=i" => \$option_width,
             "strip-signature|s" => \$option_stripsignature,
             "quote|q=i" => \$option_quote,
             "indent|i=i" => \$option_indent,
             "max-quote|m=i" => \$option_maxquote,
             "min-width|y=i" => \$option_minwidth,
             "help|h" => sub { Syntax(); exit(0); }
        ))
    {
        Syntax();
        die "Bad options";
    }

    if ($#ARGV >= 0)
    {
        Syntax();
        die "Bad options";
    }
}

sub empty
{
    @unquotedlines =();
    @rawlines = ();
}

sub msubstr
{
    my $t = shift @_;
    my $s = shift @_;
    my $l = shift @_;
    my $len = length ($t);
    $l = $len unless defined($l);
    return "" if ($s >= $len);
    $l = $len-$s if ($s+$l > $len);
    return substr($t, $s, $l);
}

sub getquoteprefix
{
    my $level = shift @_;
    my $noindent = shift @_;
    $level = $quotes unless defined($level);
    $level += $option_quote;
    $level = 0 if ($level<0);
    my $quoteprefix = "> " x $level;
    $quoteprefix = ("> " x ($option_maxquote-1))."... > " if ($level > $option_maxquote);
    $quoteprefix.= "    " x $option_indent if (($option_indent > 0) && !$noindent);
    return $quoteprefix;
}

sub outputwrap
{
    my $text = join(' ', @unquotedlines);
    $text =~ s/\s+/ /g;
    my $quoteprefix = getquoteprefix;
    my $width = $option_width - length($quoteprefix);
    $width = $option_minwidth if ($width<$option_minwidth);
    while ($text !~ /^\s*$/)
    {
	# remove leading spaces and trailing spaces
	$text =~ s/^\s+//g;
	$text =~ s/\s+$//g;
	my $breakat=$width-1;
	if ($breakat >= length($text))
	{
	    $breakat = length($text); # an index one beyond last
	}
	else
	{
	    for (;
		 ($breakat > 0) && (msubstr($text, $breakat, 1) !~ /\s/);
		 $breakat--) {}
	    # handle words too big to fit. Often URLs so just go over width
	    if (!$breakat)
	    {
		for ($breakat = $width-1;
		     ($breakat<length($text)) && (msubstr($text, $breakat, 1) =~ /\S/);
		     $breakat++) {}
	    }
	}
	my $fragment = msubstr($text, 0, $breakat);
	$fragment =~ s/^\s+//g;
	$fragment =~ s/\s+$//g;
	$text = msubstr($text, $breakat+1);
	print $quoteprefix.$fragment."\n";
    }
}

sub outputsignature
{
    return if ($option_stripsignature);
    my $quoteprefix = getquoteprefix;
    foreach my $fragment (@unquotedlines)
    {
	$fragment =~ s/\s+$//g unless ($fragment =~ /^--/);
	print $quoteprefix.$fragment."\n";
    }
}

# Called with a parameter of the unquoted text to output with \n's in
sub outputdontwrap
{
    my $quoteprefix = getquoteprefix;
    foreach my $fragment (@unquotedlines)
    {
	$fragment =~ s/\s+$//g;
	print $quoteprefix.$fragment."\n";
    }
}

sub output
{
    if ($#rawlines >= 0)
    {
	if ($mode == wrap)
	{
	    outputwrap;
	}
	elsif ($mode == signature)
	{
	    outputsignature;
	}
	elsif ($mode == dontwrap)
	{
	    outputdontwrap;
	}
	else
	{
	    die "Bad mode";
	}
	$lastblank = 0 if ($#unquotedlines >= 0) && (join ('',@unquotedlines) ne "");
    }
    empty;
}

ParseOptions;

while (<>)
{
    chomp;

    # replace tabs with 8 spaces
    s/\t/        /g;

    my $line = $_;
    my $unqline = $line;
    my $quotelevel = 0;
    while ($unqline =~ s/^\s*>( )?//)
    {
	$quotelevel++;
    }

    for (my $ui=0 ; $ui < -$option_indent; $ui++)
    {
	$unqline =~ s/^\s{1,4}//;
    }

    if ($line =~ /^\s*$/)
    {
	output;
	my $quoteprefix = getquoteprefix(0, 1);
	print "$quoteprefix\n";
	$mode = wrap;
	$quotes = 0;
	$lastblank = 1;
	next; # do not record this line
    }
    elsif ($unqline =~ /^--( )?$/ && $lastblank) # Signature separator
    {
	output;
	$mode = signature;
	$quotes = 0;
    }
    elsif ($unqline =~ /^\s*$/)
    {
	output;
	$mode = wrap;
	$mode = dontwrap if ($unqline=~/^\s/);
	$quotes = $quotelevel;
	my $quoteprefix = getquoteprefix(undef, 1);
	print "$quoteprefix\n";
	$lastblank = 1;
    }
    elsif ($quotelevel != $quotes)
    {
	my $oldquotelevel = $quotes;
	# Quote level changed without a blank line - how rude
	output;
	$mode = wrap;
	$mode = dontwrap if ($unqline=~/^\s/);
	$quotes = $quotelevel;
	if (!$lastblank && ($quotelevel<$oldquotelevel)) # else we add spaces after 'On ... x wrote'
	{
	    my $quoteprefix = getquoteprefix(($oldquotelevel<$quotelevel)?$oldquotelevel:$quotelevel, 1);
	    print "$quoteprefix\n";
	    $lastblank = 1;
	}
    }
    elsif (($mode==wrap) && ($unqline=~/^\W/))
    {
	# Do not output, we want to reinterpret the buffer as dontwrap
	# this catches ASCII art, patches, and most code
	$mode = dontwrap;
    }

    # Record line
    push @rawlines, $line;
    push @unquotedlines, $unqline;
}

output;
